# Fundamentals

## 操作系统定义

操作系统是用户和硬件的中介，二者紧密相连。

**1.可以使硬件更方便地被使用**

**2.管理系统资源，程序执行时所需的时间和空间，然而有的时候会出现冲突的目标，比如：最大化程序的吞吐量以及最小化响应时间**

**3.以一种更高效的方式使用硬件**

<img src="./assets/image-20250303210544456.png" alt="image-20250303210544456" style="zoom: 67%;" />



操作系统也可以表述为**用户应用程序和硬件之间的软件层**，**通过硬件接口抽象硬件，隐藏了运行时的大量细节**。

<img src="./assets/image-20250303210647613.png" alt="image-20250303210647613" style="zoom:67%;" />

## CPU

基本的硬件资源有：

+ CPU：同一时间只有**一个进程**会在CPU上运行，一秒钟能运行数亿条指令，是最宝贵的资源，控制系统中所有的事物

+ Memory：容量有限，临时存储，是一种电子存储设备速度非常快，**所有运行在CPU上的程序必须在内存中**。

+ Storage(Disk)：容量大，用于储存，是一种机械装置，所有的数据以块为单位储存

+ I/O



CPU的指令集指的是CPU**能执行的指令集合**，对于不同的CPU**架构**，其所对的指令集也**不同**，不过基本上都有**load和store**指令，用于在寄存器和内存之间转化。



CPU寄存器：

通用寄存器，General Registers，**用于储存关键变量和临时结果**

特殊寄存器包括有：程序计数器PC)——**存储下一条将要执行的指令的地址**，指令寄存器(Instruction Register, IR)——**存储当前正在执行的指令**，处理器状态字(Processor Status Word, PSW)——**包含CPU运行状态的各种控制位，如模式位**



操作系统会将程序加载到**内存**中，并将内存地址存放到**PC**中，CPU会**取得，解码，执行指令**，然后根据PC获得下一条指令。

![image-20250306203627190](./assets/image-20250306203627190.png)****

## 系统类型

系统类型：

+ Batch(批处理)：可以一次性提交大量的任务，系统决定运行那些
+ Time Sharing(分时)： 多个用户可以同时连接到同一台计算机，通过划分时间片在用户之间快速切换
+ Single User Interactive：传统的个人电脑
+ Parallel ：多处理器系统，通过多个处理器并行处理任务，提高**吞吐量（throughput）和容错能力（fault tolerance）**
+ Distributed(分布式)：多个联网计算机组成
+ Real-Time(实时系统)：对硬件和软件的**响应时间**有严格要求



单任务系统：同一时间只有一个程序运行，易于实现，利用率低 MS-DOS

多任务系统：较复杂，对系统资源的利用率更高，存在安全问题，Ubuntu, Windows 10



**操作系统一定保护自己免受用户影响**：例如操作系统会保留一部分内存区域(内核空间)为只有操作系统可以访问，防止用户程序修改或者破坏系统的核心部分。

**操作系统可能会保护用户彼此之间的安全**：即防止一个用户影响到另一个用户的数据或程序，但并非所有操作系统都实现。



## 双模式

**Dual-Mode Operation（双模式操作）** 是操作系统（OS）用于保护和安全的重要机制之一，它允许计算机区分 **用户模式（User Mode）** 和 **内核模式（Kernel/Supervisory Mode）**，以确保用户程序不会直接访问关键系统资源，从而保护操作系统的稳定性和安全性。



用户模式（User Mode）：**运行所有的用户应用程序，受限访问，只能执行基本的指令不能操作硬件( I/O 设备、内存管理)，如需访问受限资源需向操作系统请求服务(system call)**

内核模式（Kernel/Supervisory Mode）：**操作系统在该模式下运行，具有完全的权限**，只能在内核模式下运行的指令称为**特权指令**Privileged  Instructions，这些指令一般会影响整个机器，包括**读取/设置时间，读取文件，访问打印机**。

**用户永远不要在内核模式下操作**



# Ubuntu

Ubuntu是以桌面应用为主的**Linux发行版操作系统**，Linux发行版包括**Linux内核**(kernel负责管理**硬件资源**，如CPU，内存，磁盘网络并**提供系统调用接口**，使得应用程序可用与硬件交互)，以及其他工具。

 

# shell

shell是一种与**操作系统交互的程序**(命令行解释器，**包围着内核**)，提供用户与操作系统内核之间的**接口**。它**接收**用户输入的命令，**解释并传递给操作系统执行**，最后将执行结果**返回**给用户。



shell的**运行机制**大体上如下

<img src="./assets/image-20250311212119862.png" alt="image-20250311212119862" style="zoom:50%;" />

<img src="./assets/image-20250311215819474.png" alt="image-20250311215819474" style="zoom:50%;" />

shell本身是一个**进程**，当执行命令时会创建一个**子进程**来运行该命令

**对于简单的命令，shell会等待子进程结束**

使用&命令，shell不会等待进程结束，而是可以继续接受新的命令





system program系统程序是一类**特殊**的程序，利用操作系统**内核**提供的系统调用来实现各种功能，shell中的**指令**就属于系统程序。





# Process







## 进程

进程process是**运行的程序**，程序不过是储存在磁盘中的**一堆指令**，当它被加载到**内存**中时便成为了一个进程。

所有的进程都是**init进程**的子进程	

进程有一个**程序计数器(**Program Counter)用于**追踪即将执行的下一条指令**，同时每个进程都有自己的**地址空间**(address space进程可以**读写的内存区域**)，防止进程之间相互干扰。



进程被**进程标识符(pid)**标识





注意下图只是一个演示，这些段在物理内存中的位置**可能不连续**，但操作系统通过**虚拟内存管理**，会将这些分散的段映射到进程的虚拟地址空间，使得进程**认为自己的内存是连续的**。

<img src="./assets/image-20250306201343030.png" alt="image-20250306201343030" style="zoom:67%;" />

进程的空间可以划分为

+ 代码段：**存放可执行程序的指令代码，可共享对于频繁使用的程序只需在内存中保留一个副本，且是只读的防止被修改**
+ 数据段：**存放已初始化的全局变量和静态变量**
+ 堆：由 `malloc`、`calloc`、`realloc` 等**动态分配函数申请**，存储动态分配的内存，**向高地址增长，大小可变**

+ 栈：**存放函数调用相关信息(其中有局部变量)，向低地址增长**



**多次调用相同的程序会创建多次不同的地址空间**



除了单进程外，还有**multiprocess**模式用于**防止崩溃**，比如浏览器。



## 僵尸进程

僵尸进程指**子进程已经终止，但父进程未回收其退出状态的进程。**而孤儿进程**orphan**指的是父进程未等待子进程就结束。 



形成过程如下：

1. **父进程调用fork创建子进程**
2. **子进程结束任务后调用exit()终止，进入终止状态(Terminated State)**
3. **此时子进程的状态还保留在PCB中，当子进程退出时，系统不会立即清空它的PCB而是保留其退出状态，知道父进程调用wait进行回收**
4. **如果父进程未调用wait回收资源，那么子进程的资源是不会被释放的**

<img src="./assets/image-20250310222618449.png" alt="image-20250310222618449" style="zoom:67%;" />

**top**指令会显示进程的信息。



## PCB

PCB 进程控制块，每个进程都会有一个对应的PCB，它是**内核中储存进程信息的数据结构**。

<img src="./assets/image-20250313220714279.png" alt="image-20250313220714279" style="zoom:50%;" />



它包括的信息有

+ **进程标识符**
+ **处理机状态：通用寄存器，PC，PSW，用户栈指针**
+ **进程调度信息：进程状态，进程优先级，进程调度所需的其他信息(调度算法)，事件(阻塞原因)**
+ **进程资源：内存空间，打开的文件**

















## 进程运行

下述是进程运行的状态图

<img src="./assets/image-20250306194855822.png" alt="image-20250306194855822" style="zoom: 67%;" />

+ New: **进程首先被创建，还未被操作系统接收**
+ Ready: **进程已分配资源但尚未执行，等待CPU调度(Dispatch)**
+ Running: **进程在CPU上运行**
  + Timeout超时: **进程被剥夺CPU，回到Ready队列**
  + Event Wait等待事件: **进程进入Blocked（阻塞）**
  + Release释放: **进程执行完毕进入Exit终止状态**

+ Blocked: **等待某个事件完成**
+ Exit: **进程执行完毕，操作系统释放其资源**





 **每种状态都会维护一个队列，其中运行状态的队列大小为一**



<img src="./assets/image-20250306195625231.png" alt="image-20250306195625231" style="zoom: 67%;" />



如下所示，**操作系统调度也要耗费时间**，这段时间中系统不会做有用的工作，越复杂的OS和PCB，切换所需的事件也就越长。

<img src="./assets/image-20250306195838057.png" alt="image-20250306195838057" style="zoom:67%;" />



**进程切换(context switch)**指的是**操作系统暂停当前正在运行的进程，保存它的状态，并加载另一个进程的状态使其继续运行。**一般发生在**进程等待I/O，或者运行了一段时间的时候**。



**context指进程的完整运行状态，包括CPU寄存器，内存....**，也就是储存在**PCB**中的内容，有的硬件可以一次性加载**多个**context。



<img src="./assets/image-20250313221234157.png" alt="image-20250313221234157" style="zoom:67%;" />



假设要从进程A切换到进程B，过程如下：

+ 保存A的**上下文context**到**进程控制块PCB中**
+ 选择下一个要运行的进程B
+ **加载B的上下文**
+ **CPU将控制权交给B，B从上次中断的地方继续运行**





## 子进程

通过fork可以创建一个和父进程有**相同状态**的子进程(子进程也会有自己**不同的资源**，比如pid)，但该进程拥有自己**独立的空间**；子进程继承父进程的**文件描述符**(注意不是拥有**同一个**)，即共同操作文件，对同一文件的写入**不会被覆盖但是顺序不确定**；子进程从**fork的下一行**开始执行。



父进程和子进程的执行顺序是**不确定**的。



在一些操作系统中，为了防止僵尸进程的出现，当父进程终止时，**它的子孙进程也会跟着终止**，这是由**操作系统**完成完成的。



**fork()会返回两次，子进程会获得pid=0，父进程会获得子进程的标识符**，如果失败(一般是带到进程的上限)会返回**-1**

<img src="./assets/image-20250311214120139.png" alt="image-20250311214120139" style="zoom:50%;" />



**getpid()返回进程的PID getppid()返回父进程的PPID**



父进程需要等待子进程结束，**PID=wait(int *statue)**将**阻塞**程序直到**任意**子进程**结束执行**或者**发送中断信号SIGINT**，它会返回 **已退出的子进程的 PID**，如果不存在子进程则会返回**-1**，其中**statue**会储存进程的**返回状态**，传入**NULL**表示不储存。waitpid会等待**指定的进程**结束。



## Schedulers

Schedulers 调度器 **从所有可执行的进程中选一个进程执行**

CPU的进程调度目标是 **最大化CPU利用率**，并通过**快速切换进程实现时间共享**



操作系统中有三种队列：

+ 作业队列 **job queue** 储存**系统中所有的进程**(包括运行的和等待的)
+ 就绪队列**ready queue** **存储放入内存，并且等待CPU执行的进程**
+ 储存设备队列 **device queue**  **等待I/O设备完成操作的进程**。进程在这三种队列中**转换**。

<img src="./assets/image-20250313223621344.png" alt="image-20250313223621344" style="zoom: 67%;" />



调度器分为两种：

+ **Short-term Scheduler 或 CPU Scheduler：**选择**下一个**要执行的进程，执行频率**较快**milliseconds，可能是系统中的**唯一**的调度器
+ **Long-term scheduler 或 job scheduler：**选择哪些进程被**加载到内存中**(ready queue) ，调用频率**较低**sec min
+ **Medium-term Scheduler：**从内存中**移除**一个进程并将其储存到磁盘上，当需要时再从磁盘中**重新加载**到内存中执行，因为内存是有限的，当进程太多时会通过**swapping**机制处理，swap-in从磁盘中加载到内存，swap-out从内存加载到磁盘。可以提高内存利用率，实现了虚拟内存，基于优先级调度，但是性能下降，数据容易丢失，page fault增加



<img src="./assets/image-20250314220850019.png" alt="image-20250314220850019" style="zoom:67%;" />





进程分为：

+ **I/O-bound process(I/O受限型，I/O密集型)：**大部分时间进行**I/O操作**，占据CPU时间**较短**，通常是短暂的CPU突发(short CPU bursts)
+ **CPU-bound process(CPU受限型，计算密集型)：**花费大部分时间**计算**，**few long CPU bursts**



Long-term scheduler负责**平衡 ** I/O-bound进程和CPU-bound进程的**比例**，**防止系统在运行时不会因为I/O等待过多而陷入空闲，或者CPU资源被计算密集型进程沾满而导致其他系统饥荒。**















# 异常

定义：由于**处理器状态变化**而导致**控制流发生突然改变**的情况，这里介绍的是**操作系统的异常**而非程序语言中的异常。



异常分为两大类：**同步异常(Synchronous)和异步异常(Asynchronous)**

同步异常包括：**除0，请求I/O，请求更多的堆内存**，**访问受限的内存**（如访问内核地址，越界），**访问尚未加载到内存的变量**(虚拟内存)

异步异常包括：**键盘输入，磁盘完成数据读取**



<img src="./assets/image-20250306204659309.png" alt="image-20250306204659309" style="zoom:67%;" />

​	



异常与函数调用的异同

异常在某些方面类似于函数调用：

+ **控制流转移**
+ **执行处理代码**
+ **执行后返回**



区别在于：

+ **函数调用只保留返回地址，而异常会保留所有寄存器的值**

+ **异常会将数据压入操作系统栈而非应用程序栈，**
+ **异常的处理程序在内核模式下运行**
+ **异常可能会返回到当前指令，或者不返回，而非一定返回到下一指令**



异常有四种类型：Interrupts，Traps，Faults，Aborts



**Interrupts由外部设备触发，例如键盘输入会发送中断信号给 CPU，磁盘读取完成后知通知CPU**

**Traps由程序主动触发的异常，通常用于请求操作系统服务，例如请求I/O或者堆内存**

**Faults是可以恢复的异常，比如访问受限内存，虚拟内存**

**Aborts是无法恢复的异常，程序会直接崩溃，比如过热**



<img src="./assets/image-20250306211850353.png" alt="image-20250306211850353" style="zoom:67%;" />



发生中断时，处理器会设置PC**指向中断处理程序的起始地址**，并从**用户模式切换到内核模式**，处理中断的程序可以执行**特权指令(因为切换到了内核态)，切换回来时会重新设置PC**。

**TRAP 指令**会让CPU **从用户模式切换到内核模式**，**用户进程的状态会被保存**，在操作系统执行完处理程序后，**会恢复进程的状态**，然后执行用户模式。



# 轮询和中断

轮询polling——**CPU定期检查设备的状态以确定是否可以进行数据传输**，一般是通过读取设备状态寄存器来判断，类似于是不是查看手机确定时间。



Interrupt**允许设备在需要CPU时主动通知CPU，而不是由CPU定期检查**。



每个设备都会有一个**中断线(interrupt line)**，**用于在数据完成传输时通知处理器**，当中断信号触发时，处理器执行**中断处理程序**，没有设备需要服务时则不会有**额外的开销**。

CPU中有一个包含**每个设备类型的表**，表中存储着与设备有关的**中断处理程序的入口地址**，每当CPU收到中断信号时它都会**查找**表，找到对应的程序入口地址然后执行。



大多中断程序使用汇编语言写的，因为**高效**。



# System Call

系统调用**操作系统提供给用户程序的接口，用于访问内核功能(文件读取，进程管理，文件管理，网络通信)**，只有通过**软中断**进入内核态才能使用。



系统调用分为三大类：**文件操作，进程管理，信息管理**



文件是**比特的序列**，内核并没有使用**数据结构**来管理文件，文件按照**树形结构的目录**组织(Tree-Structured Directories)，目录本身也是一个**文件**，储存了**如何寻找其他文件的内容**。

<img src="./assets/image-20250310221539128.png" alt="image-20250310221539128" style="zoom:67%;" />







系统调用的过程：

+ **用户调用read()函数，此时不会直接进入内核态，而是先执行一些处理步骤**
+ **函数的参数存入CPU寄存器**
+ **每个系统调用有个唯一的系统调用号，这个编号被放入特定寄存器**
+ **执行read()函数内部的中断指令，切换到内核态**
+ **通过系统调用号找到对应的系统处理函数**
+ **内核的系统调用处理函数读取寄存器内容，解析read()传入的参数**
+ **执行read的系统调用处理函数**
+ **返回到用户态**



**POXIS是一组标准，规定了API，使得应用程序可以在不同的UNIX系统上运行。**

常用的有：

![image-20250306223551232](./assets/image-20250306223551232.png)

![image-20250306223556994](./assets/image-20250306223556994.png)

![image-20250306223603452](./assets/image-20250306223603452.png)



# IPC

进程可以分为Cooperating和Independent，前者可以**影响或者收到其他进程的影响**，后者则不会



IPC指**进程间通信**，有两种方式：一种是**共享内存**(管道)，另一种则是**传递信息**。

<img src="./assets/image-20250314223636530.png" alt="image-20250314223636530" style="zoom:50%;" />



单工：只支持数据在一个方向上传输

半双工half-duplex：**允许数据在两个方向上传输，但同一时间只允许在一个方向上传输**

全双工full-duplex：**允许数据同时在两个方向上传输**



管道分为**Ordinary Pipes和Named Pipes**

Ordinary Pipes(anonymous pipes)：**只能在父子进程中通信，数据是单向的，不能被其他进程访问。**

Named Pipes：**不限制父子进程。**



除了管道还有socket，**不需要父子进程的关系，可以在不同机器之间通信**。



操作如下，注意**0是读，1是写**：

<img src="./assets/image-20250314225814984.png" alt="image-20250314225814984" style="zoom:67%;" />



父子进程想要通过管道通信，还需要**重定向输入输出**

```C++
int pid, p[2];
// 创建管道失败
if (pipe(p) == -1)
    exit(1);
pid = fork();
if (pid == 0) {
    // 子进程关闭写端
    close(p[1]);
    // 重定向输入到读端
    dup2(p[0], 0);
    // 关闭读端，否则会出问题
    close(p[0]);
    execl(...);
}
else {
    // 同理，用不到读端
    close(p[0]);
    // 重定向后关闭
    dup2(p[1], 1);
    close(p[1]);
    ... write to stdout
    wait(&status);
}

```





# Linux操作

## 目录

+ / 根目录 ： **所有目录挂在其下**
+ /boot：**存放Ubuntu内核和系统启动文件。系统启动时这些文件先被装载。**
+ /etc：**系统的配置文件目录。密码文件、设置网卡信息、环境变量的设置等都在此目录中，许多网络配置文件也在其中**。
+ /lib ：**根文件系统目录下程序和核心模块的共享库。这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32目录，几乎所有的应用程序都需要用到这些共享库。**
+ /media ：**主要用于挂载多媒体设备。ubuntu系统自动挂载的光驱、usb设备，存放临时读入的文件。**
+ /proc ：**这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。**
+ /sbin ：**s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序，如系统管理、目录查询等关键命令文件。**
+ /tmp ：这**个目录是用来存放一些临时文件的，所有用户对此目录都有读写权限**。
+ /home ：**用户的主目录。下面是自己定义的用户名的文件夹。每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。**
+ /mnt：**此目录主要是作为挂载点使用。通常包括系统引导后被挂载的文件系统的挂载点。如挂载Windows下的某个分区。**

​	

启动Ubuntu可以通过power shell输出**wsl**，如果要退出回window则输出**exit**指令	



## 指令

+ **ls 列出目录内容 -l显示详细信息，-a包括隐藏文件**
+ **pwd输出当前位置**
+ **cd 切换目录**
+ **ps查看系统中的进程信息 ps -el显示完整信息**
+ **rm name 删除文件(\*删除所有*) -f强制删除不确认 rmdir删除空目录**
+ **mkdir directory_name创建目录**
+ **cat filename显示文件内容(可以同时显示多个文件内容) cat>filename覆写文件内容（追加用>>），如果文件不存在则创建，使用ctrl+d退出编辑**

![image-20250309205649605](./assets/image-20250309205649605.png)

​	**cat file1 file2 > file3将前两个文件的内容合并到第三个文件中，同样是不存在则创建，存在则覆写**

![image-20250309210013750](./assets/image-20250309210013750.png)

+ **echo输出文本到终端 echo “text”**

+ **cp复制文件或目录，cp file1.txt /home/user/documents/复制文件到目录下，cp -r dir1/ dir2/复制一个目录的所有内容到另一个目录下。**

<img src="./assets/image-20250309210222350.png" alt="image-20250309210222350" style="zoom:80%;" />

+ **mv用于移动或重命名文件，mv oldfile.txt newfile.txt重命名(新名称存在就覆盖)，mv file1.txt /home/user/documents/移动到目录，mv oldfile.txt /home/user/documents/newfile.txt移动到目录同时重命名。**

<img src="./assets/image-20250309210720195.png" alt="image-20250309210720195" style="zoom:80%;" />

+  **wc filename 输出文件中的行数，字数(空格分割)，字符数  wc -c filename只输出字符数 wc -l filename只输出行数**

![image-20250309211254465](./assets/image-20250309211254465.png)

+ **sort filename 排序文件内容，以行划分字符串按升序进行，sort -r filename倒序**

<img src="./assets/image-20250309211656996.png" alt="image-20250309211656996" style="zoom:80%;" />



## I/O重定向

每个进程启动时，通常会**自动拥有三个标准文件描述符012**，分别用于**输入stdin**，**输出stdout**，和**错误输出stderr**

在shell中可以通过**I/O重定向**，让程序的输入输出不在依赖默认的屏幕和键盘，而是文件



从文件中读取

```shell
./a.out < input.txt
```

结果输出到文件中

```shell
./a.out > output.txt
```

将错误信息存入文件中

```shell
./a.out 2> error.txt
```



同时修改输入输出和错误文件

```python
./a.out < input.txt > output.txt 2> error.txt
```



dup函数**复制**一个**已存在**的文件描述符，并返回一个**新的文件描述符**，二者指向**相同的文件表项**，共享**文件偏移量**以及**文件状态标志**(返回**-1**，如果失败)，新文件描述符会使用**当前最小的可用文件描述符**。

```python
int dup(int oldfd);
```



每个进程都有自己的文件描述符表，当新打开一个文件时会添加一个表项

![image-20250316200857698](./assets/image-20250316200857698.png)



如下图所示：首先**打开**一个文件描述符，随后**关闭标准输出**(**0 标准输入，1标准输出，2标准错误**)，通过**dup(fd)**将标准输出定向到文件，因为此时**最小的可用文件描述符是标准输出**，dup的返回也就是标准输出，这里不需要接受返回值，至此将**标准输出定向到了文件**，最后关闭原来指向文件的描述符。

<img src="./assets/image-20250316184638261.png" alt="image-20250316184638261" style="zoom:50%;" />

dup2相较于dup，**可以指定将oldfd复制给谁**



## exec

exec代表**一组**可以替换当前进程的系统调用，它不会**创建**新的进程，而是用**新的程序序替换当前程序的数据和代码**。注意**PID**，**PPID**和**已经打开的文件描述符**会保留。



当调用该`exec` 族函数时：

1. **关闭当前程序的代码和数据，当进程的PID不变**
2. **加载新程序**
3. **执行该程序并且不会返回，如果调用失败会返回-**1





p表示在**环境变量**PATH的目录里去查找要执行的可执行文件，e则是**自定义环境变量**，不加p则需要传入**完整的路径**。

e和l表示**参数的传递方式**，前者**一个一个列举**，后者使用**数组**，二者都需要用**NULL**结尾。

注意参数(不包括)中的第一个是**程序名**。

<img src="./assets/image-20250312225918527.png" alt="image-20250312225918527" style="zoom:67%;" />

```C++
// 枚举传参
execl("/bin/ls", "ls", "-l", NULL);

// 列表传参
char *args[] = {"ls", "-l", NULL};
execv("/bin/ls", args);

execlp("ls","ls","-l","a.c",NULL);
```









## 管道

**| 管道符可以将两个命令分开，左边的命令的输出作为右边的命令的输入**，可以**连续使用**即第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。



将三个文件的内容排序后输出到打印设备，在后台执行

```bash
 cat file1 file2 file3 | sort  >/dev/lp &
```

